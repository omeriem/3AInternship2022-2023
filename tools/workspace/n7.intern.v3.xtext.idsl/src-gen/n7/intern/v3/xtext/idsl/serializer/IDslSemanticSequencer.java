/*
 * generated by Xtext 2.29.0
 */
package n7.intern.v3.xtext.idsl.serializer;

import com.google.inject.Inject;
import iDSL.Connexion;
import iDSL.DataFlow;
import iDSL.DataHolder;
import iDSL.DataProcessor;
import iDSL.DataProcessorDescriptor;
import iDSL.DomainParameter;
import iDSL.IDSLPackage;
import iDSL.Interfacer;
import iDSL.IotFramework;
import iDSL.Output;
import iDSL.PreProcessor;
import iDSL.PreProcessorDescriptor;
import iDSL.Reference;
import iDSL.StreamDescriptor;
import iDSL.Synchronizer;
import iDSL.SynchronizerDescriptor;
import iDSL.Thing;
import java.util.Set;
import n7.intern.v3.xtext.idsl.services.IDslGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class IDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private IDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == IDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case IDSLPackage.CONNEXION:
				sequence_ConnexionBlock(context, (Connexion) semanticObject); 
				return; 
			case IDSLPackage.DATA_FLOW:
				sequence_DefinitionInstruction(context, (DataFlow) semanticObject); 
				return; 
			case IDSLPackage.DATA_HOLDER:
				if (rule == grammarAccess.getAnomynousHolderRule()) {
					sequence_AnomynousHolder(context, (DataHolder) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getHolderBlockRule()) {
					sequence_HolderBlock(context, (DataHolder) semanticObject); 
					return; 
				}
				else break;
			case IDSLPackage.DATA_PROCESSOR:
				sequence_ProcessorAssignation(context, (DataProcessor) semanticObject); 
				return; 
			case IDSLPackage.DATA_PROCESSOR_DESCRIPTOR:
				sequence_DataProcessorBlock(context, (DataProcessorDescriptor) semanticObject); 
				return; 
			case IDSLPackage.DOMAIN_PARAMETER:
				sequence_DomainParameterBlock(context, (DomainParameter) semanticObject); 
				return; 
			case IDSLPackage.INTERFACER:
				sequence_OutputAssignation(context, (Interfacer) semanticObject); 
				return; 
			case IDSLPackage.IOT_FRAMEWORK:
				sequence_IotFramework(context, (IotFramework) semanticObject); 
				return; 
			case IDSLPackage.OUTPUT:
				sequence_OutputBlock(context, (Output) semanticObject); 
				return; 
			case IDSLPackage.PARAMETER:
				sequence_ParameterExpression(context, (iDSL.Parameter) semanticObject); 
				return; 
			case IDSLPackage.PRE_PROCESSOR:
				sequence_PreProcessorAssignation(context, (PreProcessor) semanticObject); 
				return; 
			case IDSLPackage.PRE_PROCESSOR_DESCRIPTOR:
				sequence_PreProcessorBlock(context, (PreProcessorDescriptor) semanticObject); 
				return; 
			case IDSLPackage.REFERENCE:
				sequence_ReferenceName(context, (Reference) semanticObject); 
				return; 
			case IDSLPackage.STREAM_DESCRIPTOR:
				if (rule == grammarAccess.getAnonymousStreamDefinitionRule()) {
					sequence_AnonymousStreamDefinition(context, (StreamDescriptor) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStreamDefinitionRule()) {
					sequence_StreamDefinition(context, (StreamDescriptor) semanticObject); 
					return; 
				}
				else break;
			case IDSLPackage.SYNCHRONIZER:
				sequence_SynchronizerAssignation(context, (Synchronizer) semanticObject); 
				return; 
			case IDSLPackage.SYNCHRONIZER_DESCRIPTOR:
				sequence_SynchronizerBlock(context, (SynchronizerDescriptor) semanticObject); 
				return; 
			case IDSLPackage.THING:
				sequence_ThingBlock(context, (Thing) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnomynousHolder returns DataHolder
	 *
	 * Constraint:
	 *     (streamdescriptors+=AnonymousStreamDefinition* streamdescriptors+=AnonymousStreamDefinition)
	 * </pre>
	 */
	protected void sequence_AnomynousHolder(ISerializationContext context, DataHolder semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnonymousStreamDefinition returns StreamDescriptor
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 * </pre>
	 */
	protected void sequence_AnonymousStreamDefinition(ISerializationContext context, StreamDescriptor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IDSLPackage.Literals.STREAM_DESCRIPTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IDSLPackage.Literals.STREAM_DESCRIPTOR__NAME));
			if (transientValues.isValueTransient(semanticObject, IDSLPackage.Literals.STREAM_DESCRIPTOR__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IDSLPackage.Literals.STREAM_DESCRIPTOR__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnonymousStreamDefinitionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAnonymousStreamDefinitionAccess().getTypeTypeEnumRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConnexionBlock returns Connexion
	 *
	 * Constraint:
	 *     (description=STRING? name=ID parameters+=DomainParameterBlock+)
	 * </pre>
	 */
	protected void sequence_ConnexionBlock(ISerializationContext context, Connexion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataProcessorBlock returns DataProcessorDescriptor
	 *
	 * Constraint:
	 *     (
	 *         description=STRING? 
	 *         name=ID 
	 *         (
	 *             (inputdataflowdescriptors+=[DataFlowDescriptor|ID]+ inputdataflowdescriptors+=[DataFlowDescriptor|ID]) | 
	 *             inputdataflowdescriptors+=[DataFlowDescriptor|ID] | 
	 *             anomynousinputdataflowdescriptors+=AnomynousHolder
	 *         ) 
	 *         anomynousinputdataflowdescriptors+=AnomynousHolder* 
	 *         (
	 *             (outputdataflowdescriptors+=[DataFlowDescriptor|ID]+ outputdataflowdescriptors+=[DataFlowDescriptor|ID]) | 
	 *             outputdataflowdescriptors+=[DataFlowDescriptor|ID] | 
	 *             anomynousoutputdataflowdescriptors+=AnomynousHolder
	 *         ) 
	 *         anomynousoutputdataflowdescriptors+=AnomynousHolder* 
	 *         parameters+=DomainParameterBlock+
	 *     )
	 * </pre>
	 */
	protected void sequence_DataProcessorBlock(ISerializationContext context, DataProcessorDescriptor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DefinitionInstruction returns DataFlow
	 *
	 * Constraint:
	 *     (name=ID dataflowdescriptor=[DataFlowDescriptor|ID]?)
	 * </pre>
	 */
	protected void sequence_DefinitionInstruction(ISerializationContext context, DataFlow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DomainParameterBlock returns DomainParameter
	 *
	 * Constraint:
	 *     (name=ID parameters+=ParameterExpression*)
	 * </pre>
	 */
	protected void sequence_DomainParameterBlock(ISerializationContext context, DomainParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     HolderBlock returns DataHolder
	 *
	 * Constraint:
	 *     (description=STRING? name=ID (parameters+=DomainParameterBlock | streamdescriptors+=StreamDefinition)+)
	 * </pre>
	 */
	protected void sequence_HolderBlock(ISerializationContext context, DataHolder semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IotFramework returns IotFramework
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             dataflowdescriptors+=ThingBlock | 
	 *             dataflowdescriptors+=OutputBlock | 
	 *             dataflowdescriptors+=HolderBlock | 
	 *             interfacerdescriptors+=SynchronizerBlock | 
	 *             interfacerdescriptors+=PreProcessorBlock | 
	 *             interfacerdescriptors+=DataProcessorBlock
	 *         )* 
	 *         description=STRING? 
	 *         name=ID 
	 *         (
	 *             dataflows+=DefinitionInstruction | 
	 *             interfacers+=SynchronizerAssignation | 
	 *             interfacers+=PreProcessorAssignation | 
	 *             interfacers+=ProcessorAssignation | 
	 *             interfacers+=OutputAssignation
	 *         )+
	 *     )
	 * </pre>
	 */
	protected void sequence_IotFramework(ISerializationContext context, IotFramework semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OutputAssignation returns Interfacer
	 *
	 * Constraint:
	 *     (outputs+=[DataFlow|ID]* outputs+=[DataFlow|ID] inputs+=[DataFlow|ID]* inputs+=[DataFlow|ID])
	 * </pre>
	 */
	protected void sequence_OutputAssignation(ISerializationContext context, Interfacer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OutputBlock returns Output
	 *
	 * Constraint:
	 *     (description=STRING? name=ID parameters+=DomainParameterBlock+)
	 * </pre>
	 */
	protected void sequence_OutputBlock(ISerializationContext context, Output semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterExpression returns Parameter
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             content=STRING | 
	 *             content=INT | 
	 *             content=NINT | 
	 *             content=BOOLEAN | 
	 *             content=FLOAT | 
	 *             content=CHAR | 
	 *             content=LONG | 
	 *             content=BYTE | 
	 *             content=DOUBLE
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_ParameterExpression(ISerializationContext context, iDSL.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PreProcessorAssignation returns PreProcessor
	 *
	 * Constraint:
	 *     (outputs+=[DataFlow|ID]* outputs+=[DataFlow|ID] inputs+=[DataFlow|ID]* inputs+=[DataFlow|ID] interfacerdescriptor=[PreProcessorDescriptor|ID])
	 * </pre>
	 */
	protected void sequence_PreProcessorAssignation(ISerializationContext context, PreProcessor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PreProcessorBlock returns PreProcessorDescriptor
	 *
	 * Constraint:
	 *     (
	 *         description=STRING? 
	 *         name=ID 
	 *         (
	 *             (inputdataflowdescriptors+=[DataFlowDescriptor|ID]+ inputdataflowdescriptors+=[DataFlowDescriptor|ID]) | 
	 *             inputdataflowdescriptors+=[DataFlowDescriptor|ID] | 
	 *             anomynousinputdataflowdescriptors+=AnomynousHolder
	 *         ) 
	 *         anomynousinputdataflowdescriptors+=AnomynousHolder* 
	 *         (
	 *             (outputdataflowdescriptors+=[DataFlowDescriptor|ID]+ outputdataflowdescriptors+=[DataFlowDescriptor|ID]) | 
	 *             outputdataflowdescriptors+=[DataFlowDescriptor|ID] | 
	 *             anomynousoutputdataflowdescriptors+=AnomynousHolder
	 *         ) 
	 *         anomynousoutputdataflowdescriptors+=AnomynousHolder* 
	 *         parameters+=DomainParameterBlock+
	 *     )
	 * </pre>
	 */
	protected void sequence_PreProcessorBlock(ISerializationContext context, PreProcessorDescriptor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProcessorAssignation returns DataProcessor
	 *
	 * Constraint:
	 *     (outputs+=[DataFlow|ID]* outputs+=[DataFlow|ID] inputs+=[DataFlow|ID]* inputs+=[DataFlow|ID] interfacerdescriptor=[DataProcessorDescriptor|ID])
	 * </pre>
	 */
	protected void sequence_ProcessorAssignation(ISerializationContext context, DataProcessor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReferenceName returns Reference
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_ReferenceName(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IDSLPackage.Literals.REFERENCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IDSLPackage.Literals.REFERENCE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StreamDefinition returns StreamDescriptor
	 *
	 * Constraint:
	 *     (description=STRING? name=ID type=Type samplingRate=INT)
	 * </pre>
	 */
	protected void sequence_StreamDefinition(ISerializationContext context, StreamDescriptor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SynchronizerAssignation returns Synchronizer
	 *
	 * Constraint:
	 *     (outputs+=[DataFlow|ID]* outputs+=[DataFlow|ID] inputs+=[DataFlow|ID]* inputs+=[DataFlow|ID] interfacerdescriptor=[SynchronizerDescriptor|ID])
	 * </pre>
	 */
	protected void sequence_SynchronizerAssignation(ISerializationContext context, Synchronizer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SynchronizerBlock returns SynchronizerDescriptor
	 *
	 * Constraint:
	 *     (
	 *         description=STRING? 
	 *         name=ID 
	 *         (
	 *             (inputdataflowdescriptors+=[DataFlowDescriptor|ID]+ inputdataflowdescriptors+=[DataFlowDescriptor|ID]) | 
	 *             inputdataflowdescriptors+=[DataFlowDescriptor|ID] | 
	 *             anomynousinputdataflowdescriptors+=AnomynousHolder
	 *         ) 
	 *         anomynousinputdataflowdescriptors+=AnomynousHolder* 
	 *         (
	 *             (outputdataflowdescriptors+=[DataFlowDescriptor|ID]+ outputdataflowdescriptors+=[DataFlowDescriptor|ID]) | 
	 *             outputdataflowdescriptors+=[DataFlowDescriptor|ID] | 
	 *             anomynousoutputdataflowdescriptors+=AnomynousHolder
	 *         ) 
	 *         anomynousoutputdataflowdescriptors+=AnomynousHolder* 
	 *         parameters+=DomainParameterBlock+
	 *     )
	 * </pre>
	 */
	protected void sequence_SynchronizerBlock(ISerializationContext context, SynchronizerDescriptor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ThingBlock returns Thing
	 *
	 * Constraint:
	 *     (description=STRING? name=ID (connexions+=ConnexionBlock | parameters+=DomainParameterBlock | streamdescriptors+=StreamDefinition)+)
	 * </pre>
	 */
	protected void sequence_ThingBlock(ISerializationContext context, Thing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
